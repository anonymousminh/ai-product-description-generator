import json
import pytest

# Adjust sys.path to allow importing modules from src/
import sys
import os
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../../src')))

from product_generator.lambda_handlers.generate_description_lambda import lambda_handler
from product_generator.services.bedrock_service import BedrockService
from product_generator.utils.description_formatter import DescriptionFormatter

# Fixture to mock BedrockService and DescriptionFormatter
@pytest.fixture
def mock_services(mocker):
    # Mock the BedrockService class and its instance
    mock_bedrock_service_instance = mocker.MagicMock(spec=BedrockService)
    mocker.patch(
        'product_generator.lambda_handlers.generate_description_lambda.BedrockService',
        return_value=mock_bedrock_service_instance
    )

    # Mock the DescriptionFormatter class and its instance
    mock_description_formatter_instance = mocker.MagicMock(spec=DescriptionFormatter)
    mocker.patch(
        'product_generator.lambda_handlers.generate_description_lambda.DescriptionFormatter',
        return_value=mock_description_formatter_instance
    )

    # Return the mocked instances for direct manipulation in tests
    return mock_bedrock_service_instance, mock_description_formatter_instance

# Fixture to mock the logger
@pytest.fixture(autouse=True)
def mock_logger(mocker):
    mocker.patch('product_generator.lambda_handlers.generate_description_lambda.logger')

def test_successful_detailed_generation(mock_services):
    mock_bedrock_service_instance, mock_description_formatter_instance = mock_services

    # Configure mocks
    mock_bedrock_service_instance.invoke_model.return_value = "This is a very detailed description generated by Bedrock."
    mock_description_formatter_instance.get_detailed_description.return_value = "This is a very detailed description generated by Bedrock."

    event = {
        "body": json.dumps({
            "title": "Smart Coffee Maker",
            "category": "Kitchen Appliances",
            "features": ["Wi-Fi", "Voice Control"],
            "audience": "Coffee Lovers",
            "format": "detailed"
        })
    }
    context = {} # context object is often a dict or simple object in pytest

    response = lambda_handler(event, context)
    response_body = json.loads(response["body"])

    assert response["statusCode"] == 200
    assert "detailed" in response_body
    assert response_body["detailed"] == "This is a very detailed description generated by Bedrock."
    mock_bedrock_service_instance.invoke_model.assert_called_once()
    mock_description_formatter_instance.get_detailed_description.assert_called_once()

def test_successful_short_generation(mock_services):
    mock_bedrock_service_instance, mock_description_formatter_instance = mock_services

    # Configure mocks
    mock_bedrock_service_instance.invoke_model.return_value = "This is a short description. It has multiple sentences."
    mock_description_formatter_instance.get_short_description.return_value = "This is a short description."

    event = {
        "body": json.dumps({
            "title": "Smart Coffee Maker",
            "category": "Kitchen Appliances",
            "features": ["Wi-Fi", "Voice Control"],
            "audience": "Coffee Lovers",
            "format": "short"
        })
    }
    context = {}

    response = lambda_handler(event, context)
    response_body = json.loads(response["body"])

    assert response["statusCode"] == 200
    assert "short" in response_body
    assert response_body["short"] == "This is a short description."
    mock_bedrock_service_instance.invoke_model.assert_called_once()
    mock_description_formatter_instance.get_short_description.assert_called_once()

def test_missing_required_metadata(mock_services):
    mock_bedrock_service_instance, _ = mock_services

    event = {
        "body": json.dumps({
            "title": "Smart Coffee Maker",
            "category": "Kitchen Appliances",
            # Missing features and audience
        })
    }
    context = {}

    response = lambda_handler(event, context)
    response_body = json.loads(response["body"])

    assert response["statusCode"] == 400
    assert "message" in response_body
    assert "Missing required product metadata" in response_body["message"]
    mock_bedrock_service_instance.invoke_model.assert_not_called()

def test_invalid_json_body():
    event = {"body": "this is not json"}
    context = {}

    response = lambda_handler(event, context)
    response_body = json.loads(response["body"])

    assert response["statusCode"] == 400
    assert "message" in response_body
    assert "Invalid JSON in request body" in response_body["message"]

def test_bedrock_service_exception(mock_services):
    mock_bedrock_service_instance, _ = mock_services

    mock_bedrock_service_instance.invoke_model.side_effect = Exception("Bedrock API error")

    event = {
        "body": json.dumps({
            "title": "Smart Coffee Maker",
            "category": "Kitchen Appliances",
            "features": ["Wi-Fi", "Voice Control"],
            "audience": "Coffee Lovers",
            "format": "detailed"
        })
    }
    context = {}

    response = lambda_handler(event, context)
    response_body = json.loads(response["body"])

    assert response["statusCode"] == 500
    assert "message" in response_body
    assert "Failed to generate description" in response_body["message"]
    mock_bedrock_service_instance.invoke_model.assert_called_once()

